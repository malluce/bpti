\documentclass[parskip=full]{scrartcl}
\usepackage[utf8]{inputenc} % use utf8 file encoding for TeX sources
\usepackage[T1]{fontenc}    % avoid garbled Unicode text in pdf
\usepackage[german]{babel}  % german hyphenation, quotes, etc
\usepackage{hyperref}       % detailed hyperlink/pdf configuration
\hypersetup{                % ‘texdoc hyperref‘ for options
	pdftitle={Bericht},%
	bookmarks=true,%
}
\usepackage{graphicx}       % provides commands for including figures
\usepackage{csquotes}       % provides \enquote{} macro for "quotes"
\usepackage{scrpage2}
\usepackage{caption}
\usepackage{enumitem}
\pagestyle{scrheadings}
\usepackage{float}

%\clearscrheadfoot
\ohead{BPTI: Gruppe 03=\{Niklas Metz, Felix Bachmann\}, Bericht, WS 2017/18}
\title{BPTI: Bomberman in VHDL}

\begin{document}
	\maketitle
	\part{Beschreibung der Entities}
		\section{bomberman\_ent}
			%TODO blockdiagramm
			bomberman\_ent ist die Top-Level-Architektur. Die Eingänge sind die tatsächlichen Eingaben des Nutzers und auf den Ausgängen liegen die Informationen die für den VGA-Anschluss benötigt werden. in bomberman\_ent werden drei Entities miteinander verbunden. Zuerst die sync\_gen\_ent, die hsync und vsync erzeugt. Außerdem die game\_mechanic\_ent, welche die eigentliche Spiellogik enthält. Zuletzt noch die graphics\_ent, die für die Erzeugung der entsprechenden RGB-Farbwerte zuständig ist. 
			Letzere enthält ausschließlich asynchrone Entities, sync\_gen\_ent und game\_mechanic\_ent enthalten ausschließlich synchrone Entities (wenn nicht anders angegeben, kriegen diese die VGA-Clock als Takt).
			In bomberman\_ent werden außerdem die beiden Generics TILE\_SIZE und PLAYER\_SIZE definiert und mit 32 initialisiert.
		
		\section{game\_mechanic\_ent}
			%TODO blockdiagramm
			game\_mechanic\_ent ist die Architektur, welche die eigentliche Spiellogik enthält. Hier werden zwei Spieler vom Typ player\_ent erzeugt und mit der Logik in game\_state\_ent verbunden.
		
			\subsection{game\_state\_ent}
				%TODO erwähnen, dass player_collision hier gemacht wird, weil ein Spieler auch von einer Bombe getroffen werden kann, die er selbst nicht gelegt hat
			\subsection{player\_ent}
				%TODO blockdiagramm
				%TODO beschreibung
				\subsubsection{clk\_movement\_ent}
				Die Entity clk\_movement\_ent ist ein Clock Divider, die Architecture wird funktional beschrieben. Die Entity wird genutzt, um die Geschwindigkeit der Bewegung der Spieler zu steuern. Es wird alle 78125 Originaltakte die Ausgabe Ausgabe negiert. Da in unserem Design die VGA-Clock genutzt wird, wird somit alle $\frac{78125 * 2}{25.175 * 10^6}s \approx 6.2ms$ ein Takt erzeugt. Dies hat zur Folge, dass bei ständiger Bewegung eines Spielers in die gleiche Richtung, die pro steigender Takt-Flanke des ausgegebenen Takts stattfindet, die Bewegung vom linken bis zum rechten Rand des Spielfelds (480 Pixel) $480 * 6.2 ms \approx 2.98 s$ dauert. Diesen Wert haben wir bei BombermanGB über einen Emulator gemessen und \enquote{rückwärts} den nötigen Zähler, also 78125, bestimmt.
				\subsubsection{movement\_ent}
					Die Entity movement\_ent wird durch eine Architecture funktional beschrieben und ist für die Bewegung eines Spielers zuständig. Als Eingangssignale erhält die Entity sowohl die VGA-Clock, als auch die von clk\_movement\_ent generierte Clock. Weitere in-Ports sind die low-aktiven Signale des Gamepads zum Bewegen des Spielers. Zuletzt kennt die Entity durch Eingangssignale auch den Zustand des Spielfeldes. Dieser wird benötigt, um die Kollision des Spielers mit Blöcken zu prüfen.
					Die Ausgabe ist die Pixel-Position des Spielers.
					Diese wird anhand der gewünschten Bewegungsrichtung (durch die Gamepad-Signale gegeben), der in der Entity gespeicherten Pixel-Position vor der Bewegung und des aktuellen Zustandes des Spielfelds berechnet. Die Pixel-Position wird um eine in der Entity definierte Konstante verändert, falls keine Kollision mit einem Block auftritt. Jede Kachel, die nicht leer ist, führt dabei zu einer Kollision.
					Der Test auf Kollision wird jedoch nur durchgeführt, falls durch die Bewegung eine Kante des Spielers auf eine Kachel bewegt werden würde, auf der sich der Spieler vorher nicht befand. \newline
					Beispiel: Sei die Spieler- und Kachelgröße 32x32 Pixel. Die Koordinaten beginnen bei (1,1). Dann wird bei einer Bewegung nach links nur auf Kollision überprüft, falls $((x-1)$ mod $32) == 0$. Nur in diesem Fall wird eine andere Kachel betreten.\newline
					Dadurch ist es dem Spieler möglich von einer Kachel, auf der er eine Bombe gelegt hat, zu entkommen (die Bombe würde auch zu einer Kollision führen).
					Die Bewegung in x- und y- Richtung kann , falls möglich, parallel geschehen.
				\subsubsection{bomb\_ent}
					Die Entity bomb\_ent enthält die funktionale Beschreibung einer Bombe. Als Eingabe erhält die Entity die Kachel-Position des zugehörigen Spielers, um beim Legen einer neuen Bombe die Position derselben festlegen zu können. Weitere in-Ports sind das low-aktive Signal des Knopfes auf dem Gamepad zum Legen einer Bombe und das enable-Signal des zugehörigen Spielers. Letzteres wird benötigt, um zu verhindern, dass ein bereits toter Spieler eine neue Bombe legen kann.
					Die Ausgabe sind die Kachel-Position der Bombe, sowie ein enable- und ein explode-Signal. Beide Signale zusammen ergeben die verschiedenen Zustände der Bombe.
					\begin{table}[H]
						\centering
						\label{bombCode}
						\begin{tabular}{|l|l|}
							\hline
							\textbf{enable, explode} & \textbf{Zustand}      \\ \hline
							0,0         & Bombe ist nicht aktiv              \\ \hline
							0,1           & ungültiger Zustand               \\ \hline
							1,0          & Bombe ist auf dem Spielfeld, explodiert aber noch nicht \\ \hline
							1,1          & Bombe ist auf dem Spielfeld und explodiert     \\ \hline
						\end{tabular}
						\caption{Zustände der Bombe}
					\end{table}
					Zur Generierung dieser Signale finden sich in der Architecture zwei Counter. Sobald erfolgreich eine neue Bombe gelegt wurde, wird das enable-Signal auf 1 gesetzt und ein Counter beginnt. Dieser zählt (falls die VGA-Clock als Takt genutzt wird) circa drei Sekunden und symbolisiert das \enquote{Ticken} der Bombe. Sobald dieser Counter heruntergezählt hat, wird das explode-Signal auf 1 gesetzt und der zweite Counter beginnt zu zählen. Dieser zählt circa eine halbe Sekunde. Hat dieser Counter heruntergezählt wird das explode-Signal und das enable-Signal auf 0 gesetzt. Der zweite Counter wird benötigt, damit die Explosion einer Bombe eine gewisse Zeit andauert und auf dem Bildschirm für das menschliche Auge sichtbar wird.
					\begin{figure}[H]
						\centering
						\includegraphics[scale=0.4]{./bilder/bomb_sim.png}
						\caption{Simulation von bomb\_ent \newline(Takt-Dauer von 40 ns, Counter um 6 Größenordnungen verringert)}
					\end{figure}
			
		\section{graphics\_ent}
			graphics\_ent kapselt die Farbenerzeugung. Als Eingabe bekommt es die Informationen über die Positionen der Spieler und über das Spielfeld, sowie die Position des aktuell zu zeichnenden Pixels (generiert durch sync\_gen\_ent). Aus diesen Werten, wird durch pixel\_gen\_ent entschieden welche Sprites gerade verwendet werden müssen. Anschließend werden die ausgelesenen Farbinformationen in rgb\_assign\_ent auf die einzelnen Farbausgänge gelegt.\newline
			
			%TODO wie ist das gemeint? player_id und spielfeldkodierung vermischt? -> kodierung für spielfeld ins game_state kapitel, spielerkodierung unnötig? (hab ich im sprite teil schon beschrieben, sind eh nur 2 werte)
			\begin{table}[H]
				\centering
				\label{tileCode}
				\begin{tabular}{|l|l|}
					\hline
					\textbf{Wert} & \textbf{Bezeichnung}      \\ \hline
					0x0           & Leeres Feld               \\ \hline
					0x1           & Explosion                 \\ \hline
					0x2           & Spieler 1                 \\ \hline
					0x3           & Spieler 2                 \\ \hline
					0x4           & Kodierung für weißen Rand \\ \hline
					0xD           & Bombe                     \\ \hline
					0xE           & Zerstörbarer Block        \\ \hline
					0xF           & Unzerstörbarer Block      \\ \hline
				\end{tabular}
				\caption{Spielfeld-Kodierungen}
			\end{table}
		
			\begin{figure}[H]
				\centering
				\includegraphics[angle=90,scale=0.1]{./bilder/graphics_ent.jpg}
				\caption{Blockdiagramm graphics\_ent}
			\end{figure}
			
			\subsection{pixel\_gen\_ent}
				pixel\_gen\_ent bekommt als Eingaben die Informationen über die Spieler, sowie über das Spielfeld. Abhängig von diesen Informationen gibt die Entity aus, auf welche Sprites zugegriffen werden soll und an welcher Stelle.\newline
				Die 160 Spalten am linken Rand des Monitors werden bei uns dauerhaft weiß gefärbt, da wir ein quadratisches Spielfeld wollten, was allerdings bei einer Auflösung von 640x480 nicht funktioniert. Unser tatsächliches Spielfeld ist somit nun 480x480 Pixel groß.\newline
				Der erste Spieler hat bei uns den Vorrang vor dem zweiten Spieler, also falls sich beide Spieler übereinander befinden, wird der erste Spieler gezeichnet.\newline
				Wir haben unterschiedliche Ausgänge für die Informationen über die Sprites für Spielfeld und Player, um im PlayerROM entscheiden zu können ob wirklich der Spieler oder doch das Spielfeld gezeichnet wird, falls die Grafik des Spielers an der bestimmten Position transparent ist.
		
			\subsection{Sprites}
				In den beiden Entities PlayerROM und SpriteROM befinden sich Sprites, die in Abhängigkeit des aktuellen Zustands der Arena, der Spieler und der Bomben RGB-Werte an den VGA-Controller ausgeben. Dazu befinden sich in den beiden Entities PlayerROM und SpriteROM pro Sprite (es existieren Sprites für: Spieler 1, Spieler 2, leerer Block, zerstörbarer Block, unzerstörbarer Block, Bombe, Explosion) ein zweidimensionales konstantes Array (wird synthetisiert als ROM). Diese Arrays sind jeweils 32 * 384 Bit groß. \newline
				Die Größe ergibt sich folgendermaßen: Die Kacheln des Spielfeldes sowie die Quellsprites haben eine Größe von 32 * 32 Pixel. Da für jeden Farbkanal des VGA-Ausgangs 4 Bit zur Verfügung stehen haben wir in dem Array den RGB-Wert jedes Pixels mit 3 * 4 Bit (also 3 Hex-Werte) kodiert. So kommen 32 Zeilen mit jeweils 
				3 * 4 * 32 = 384 Bit zustande. \newline
				Die Sprites haben wir aus einem Sprite-Sheet von opengameart (\url{https://opengameart.org/sites/default/files/DungeonCrawl_ProjectUtumnoTileset.png}) ausgeschnitten und mithilfe eines Java-Programmes, welches im Abgabe-Verzeichnis zu finden ist und im folgenden kurz beschrieben wird, in VHDL-Arrays umgewandelt.
				\subsubsection{SpriteExtractor.java}
					Das Java-Programm bekommt als Kommandozeilenargumente die Pfade zu den 32 * 32 Pixel großen Sprites. Über jedes der Sprites wird pixelweise iteriert und für jeden Pixel der RGB-Wert ausgelesen. Daraus werden die Werte der einzelnen Farbkanäle bestimmt, welche anschließend normiert werden, da auf dem FPGA nur 4 Bit pro Farbkanal nutzbar sind. Die normierten Werte werden in Hex-Character umgewandelt und auf der Konsole ausgegeben, sodass die RGB-Kanäle jedes Pixels mit 3 Hex-Charactern  dargestellt werden. Die Ausgabe erfolgt in der Form von 32 komma-separierten std\_logic\_vectoren der Länge 384.
				\subsubsection{SpriteROM}
					Die Entity SpriteROM wird mit einer Architecture funktional beschrieben. Abhängig von der sprite\_id wird mittels sprite\_row und sprite\_col asynchron auf die verschiedenen Arrays, die Sprites für den leeren/zerstörbaren/unzerstörbaren Block enthalten, zugegriffen. Die sprite\_id orientiert sich hierbei an den Kodierungen des Spielfeldes (siehe game\_state, z.B. leerer Block = 0x0). Ist keine gültige sprite\_i gesetzt (also sprite\_id > 0x1 und sprite\_i < 0xD), wird RGB schwarz ausgegeben.
				\subsubsection{PlayerROM}
					Die Entity PlayerROM ist hinter SpriteROM geschaltet und überschreibt asynchron die RGB-Werte, die von SpriteROM ausgegeben werden, wenn sich im aktuellen Pixel des Bildes ein Spieler befindet. In PlayerROM befinden sich zwei konstante Arrays, die in der gleichen Form wie in SpriteROM die Sprites für die Spieler enthalten. PlayerROM bekommt zum Auslesen der Arrays eine player\_id (0x2 für Spieler 1, 0x3 für Spieler 2), sowie die x- und y-Position des Spielers im aktuell betrachteten Pixels. Ist die player\_id gültig, wird der RGB-Wert des entsprechenden Sprites gelesen und ausgegeben.
					Ist keine gültige player\_id gesetzt (also player\_id > 0x3 oder player\_id < 0x2), wird der RGB-Wert von SpriteROM durchgeschaltet.
					Hat ein Pixel den (in unseren Sprites speziellen) RGB-Wert 0xEEE wird ebenfalls der RGB-Wert von SpriteROM durchgeschaltet. Dies sorgt dafür, dass die Spielfiguren erkennbare Strukturen haben (Spieler sind keine Kacheln) und sich sichtbar vor einem Hintergrund bewegen.
				
			\subsection{rgb\_assign\_ent}
				In der Entity rgb\_assign\_ent werden die Farbausgänge für den Monitor gesetzt. Dazu wird bitweise auf die RGB-Eingangsvektoren zugegriffen und die einzelnen Ausgangsbits gesetzt. Diese Vorgehen am Ende der Bearbeitung erlaubt es uns während den Berechnungen mit drei Vektoren für die Farben zu arbeiten, anstatt immer 12 einzelne Bits zu benutzen.
		
		\section{sync\_gen\_ent}
			Die Entity sync\_gen\_ent wird mit einer Architecture strukturell beschrieben durch die Unterkomponenten hsync und vsync. In dieser Entity werden die Signale für den VGA-Controller generiert (also hsync und vsync). Desweiteren werden zum Setzen der Pixel die aktuelle row und column ausgegeben.
			An dieser Stelle sei auf das VGA-Übungsblatt und den Bericht darüber verwiesen. Wir haben unsere Lösung von dem Übungsblatt für das Projekt übernommen und im Laufe des Projekts nichts an der Entity inklusive Unterkomponenten geändert.
			\begin{figure}[H]
				\centering
				\includegraphics[scale=0.1]{./bilder/Sync_gen.jpeg}
				\caption{Blockdiagramm sync\_gen\_ent}
			\end{figure}
		
	\part{Probleme}
		\section{bomberman\_ent}
		
		\section{game\_mechanic\_ent}

			\subsection{game\_state\_ent}
				%TODO großes problem mit der scheiß explosion

			\subsection{player\_ent}

				\subsubsection{movement\_ent}
					%TODO reinglitchen in unzerstörbare blöcke
				\subsubsection{clk\_movement\_ent}
					
				\subsubsection{bomb\_ent}

		\section{graphics\_ent}

			\subsection{pixel\_gen\_ent}
	
			\subsection{Sprites}
				%TODO farben gefixt bekommen?

				\subsubsection{SpriteExtractor.java}

				\subsubsection{SpriteROM}

				\subsubsection{PlayerROM}

			\subsection{rgb\_assign\_ent}
		
		\section{sync\_gen\_ent}
			Ein Problem, das schon bei der Lösung des Übungsblatts aufgetaucht ist, hat sich auch durch das Projekt gezogen.
			Die VGA-Ausgabe funktioniert nicht an allen Monitoren ordnungsgemäß (es tritt ein Flackern auf). An unserem Test-Monitor hat die VGA-Ausgabe nach einigen Einstellungen jedoch funktioniert.
\end{document}
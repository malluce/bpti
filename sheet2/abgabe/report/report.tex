\documentclass[parskip=full]{scrartcl}
\usepackage[utf8]{inputenc} % use utf8 file encoding for TeX sources
\usepackage[T1]{fontenc}    % avoid garbled Unicode text in pdf
\usepackage[german]{babel}  % german hyphenation, quotes, etc
\usepackage{hyperref}       % detailed hyperlink/pdf configuration
\hypersetup{                % ‘texdoc hyperref‘ for options
	pdftitle={Entwurf},%
	bookmarks=true,%
}
\usepackage{graphicx}       % provides commands for including figures
\usepackage{csquotes}       % provides \enquote{} macro for "quotes"
\usepackage{scrpage2}
\usepackage{caption}
\pagestyle{scrheadings}
\usepackage{float}

%\clearscrheadfoot
\ohead{BPTI: Gruppe 03=\{Niklas Metz, Felix Bachmann\}, Aufgabenblatt 2, WS 2017/18}

\begin{document}
	\setcounter{section}{0}
	\section{VGA-Ausgang}
		\subsection{Probleme bei der Implementierung}
			Das größte Problem bei dieser Aufgabe war die Darstellung der weißen Ränder auf dem Bildschirm. Nachdem wir mehrfach unser Programm überprüft haben und uns sicher waren, dass zumindest 3 von 4 Rändern dargestellt werden müssten, kamen wir auf die Idee, dass der Monitor das Problem darstellt. Als wir den Bildschirm richtig einstellten wurden die drei erwarteten Ränder gezeichnet. Um den letzten verbleibenden Rand zu zeichnen behoben wir noch ein Problem beim Zählen der Größe der Ausgabe.
			
		\subsection{Entwurf}
			\includegraphics[scale=0.1]{Bilder/VGA.jpeg} \newline
			\includegraphics[scale=0.1]{Bilder/Sync_gen.jpeg}
			
		\subsection{Screenshots}
			\begin{figure}[H]
				\includegraphics[scale=0.27]{Bilder/sync.png} 
				\caption*{clk, rst , hsync und vsync}
			\end{figure}
			\begin{figure}[H]
				\includegraphics[scale=0.27]{Bilder/edge_white_rest_black.png}
				\caption*{Setzen der RGB-Werte am Rand (weiß), sonst schwarz}
			\end{figure}

	\section{Farbverlauf}
		Diese Aufgabe hat uns am meisten Zeit gekostet. Ein Problem, das wir lange Zeit übersehen hatten war, dass wir in unserem Prozess im \enquote{pixel\_gen}  einen \enquote{combanitorial loop} hatten. Wir nutzten zum Zählen der RGB-Werte eine Variable und hatten eine Zuweisung \enquote{rgb := rgb + const} im Code. Dies führte zu unerwartetem Verhalten, da es sich um einen kombinatorischen Prozess (abhängig von col und row des sync\_gen) handelt.
		Als wir diesen Fehler behoben hatten, waren wir der Meinung der Code funktioniert in der Simulation wie gewollt, das Bild hatte jedoch eine unerwartete Blockstruktur, bei der sich die RGB-Werte nach einigen Spalten des Bildes zurücksetzten. Dies war jedoch auf eine falsche Überlegung zurückzuführen, da wir die Bits für Blau und Grün nicht auf 1 ließen, obwohl beide Vektoren schon auf den Wert \enquote{1111} hochgezählt wurden.
	\section{Rechteck}
		Die Ausgabe des Rechtecks stellte uns vor keine große Herausforderung. Ein Problem war, dass wir mehrfache Zuweisungen der Ausgänge hatten und somit kein rechter Rand des Rechtecks zu sehen war, sondern das Rechteck endlos nach rechts verlief.
	
	\section{Beeinflussung der Körper}
		\subsection{Probleme}
			Das Verschieben des Körpers mittels einer Eingabe war ebenfalls kein großes Problem. Einzig die Grenzfälle an den Seiten des Bildes bedurften mehr Gedanken. Bei den ersten Versuchen könnte man den Körper nicht bis ganz in die Ecken bewegen oder darüber hinaus. Dieses Problem war allerdings auch schnell behoben.
			
		\subsection{Bedienung}
			Mit den Tasten SW5-7 lässt sich das Rechteck auf dem Bildschirm verschieben.
			\begin{itemize}
				\item Taster SW5: Bewegung des Rechtecks nach oben
				\item Taster SW6: Bewegung des Rechtecks nach unten
				\item Taster SW7: Bewegung des Rechtecks nach links
				\item Taster SW8: Bewegung des Rechtecks nach rechts
			\end{itemize}
		
		
	
\end{document}
